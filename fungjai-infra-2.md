## การมาของ Mobile App

​	ย้อนกลับไปช่วง Feb 2014 ซึ่งตอนที่แล้วผมได้เล่าไปแล้วว่าเรายังเจอปัญหาเรื่องของ Resource ไม่พอจนเราต้อง. Restart ทุกๆคืน

​	แต่ทำยังไงได้เราอยู่ในยุคสมัยของ Mobile 1st ณ สมัยนั้น อีกทั้ง Feedback ที่เราได้รับมาต่างมุ่งไปในทิศทางเดียวกันว่า พวกเค้าต้องการ Mobile Application ทำให้เราตัดสินใจที่จะต้องพัฒนา Mobile app ของฟังใจขึ้นมา พร้อมทั้งยอมติด Technical debt เรื่อง Resource มันต่อไป และแน่นอนหนี้ก่อนนี้มันแพงขึ้นเรื่อยๆเมื่อเวลาผ่านไป

​	ถึงตอนนี้เราต้องสร้าง API ให้ Mobile มาเรียกใช้ โดยทางเลือกที่ง่ายที่สุดสำหรับเราก็คือ เขียน Grails อีก 1 Controller มาเพื่อให้ Mobile เรียกแล้วส่ง JSON กลับไป

### แต่เรากลับเลือกที่จะเขียนใหม่ด้วย NodeJS

​	เรามองว่าเราอยากใช้อะไรที่มันกิน Resouce น้อยลงหน่อย ซึ่งตัวเลือกในสมัยนั้นสำหรับเราเป็น NodeJS

***"ถึงฟังใจจะรวมเพลงนอกกระแสมากที่สุดในไทย แต่ทีม dev เรากลับทำอะไรตามกระแสตลอด"***

​	จากนั้นเราได้ลอง Research nodejs framework หลายตัวทั้ง Express, Reatify และ Loopback ในสมัยนั้น (ปัจจุบันคือ Strongloop ของ IBM) สุดท้ายเราเลือก Restify ใช้ในช่วงแรก (เด๋วจะมาบอกว่าทำไมเราถึงเปลี่ยน)

​	เราใช้ Restify เนื่องจากอ่านรีวิวจากหลายๆที่เมื่อเทียบกับ Express ด้วยความเร็วที่เร็วกว่านิดหน่อย. (ซึ่งแทบไม่มีผลสำหรับเรา)

- [Why should I use Restify?](http://stackoverflow.com/questions/17589178/why-should-i-use-restify)
- [Node performance: Hapi, Express.js, Restify](https://raygun.com/blog/2015/03/node-performance-hapi-express-js-restify/)

```
fungjai api v1 with restify and redis
┌─────────────────────────────┐
│                             │
│           restify           │
│                             │
└──────▲──────────────▲───────┘
       │              │        
┌──────▼──────┐ ┌─────▼───────┐
│             │ │             │
│    MySQL    │ │    Redis    │
│             │ │             │
└─────────────┘ └─────────────┘
```

​	เราใช้ Restify ต่อกับ MySQL เช่นเดิมและใช้ Redis เพื่อมาทำ Cache JSON response

​	เราออกแบบ API ไว้ด้วยการส่ง Header 'accept-version' มาเพื่อระบุ Version ของ API ที่ Mobile เรียกใช้ เพราะว่า เรามองว่าการอัพเดท ของ Mobile app มันทำได้ยากกว่าเวป เราจึงออกแบบให้ Restify ของเราในตัวเดียวรองรับการทำงานหลาย version โดยที่เราแยกไฟล์ Controller ออกเป็น Version ๆ

```
├── app
│   ├── controllers
│   │   ├── v0.2.0
│   │   └── v0.3.0
│   ├── cores
│   ├── models
│   │   └── mapper
│   ├── parsers
│   └── utils
├── config
├── test
│   ├── integration
│   │   └── controllers
│   ├── route
│   └── unit
│       ├── controllers
│       └── models
└── test-results
```

​	ซึ่งในตอนนั้นเราเองก็ใหม่มากกับการเขียน NodeJS หรือภาษาในแนวทางของ Functional จำได้ว่าตอนนั้นวางโครงของ Code อยู่ 2 วันด้วยความไม่รู้ และแน่นอน test folder นั้นจริงๆใน version แรกมันไม่มี



## ถึงจุดเปลี่ยนเมื่อได้ลองทำงานร่วมกับ Thoughtworks

​	ถึงตรงนี้ต้องบอกว่าโชคดีมากที่ได้มีโอกาสทำงานประจำกับบริษัทธนาคารยักใหญ่ที่สุดแห่งหนึ่งในไทย ที่ลงทุนจ้าง **Thoughtworks** มาเทรน Agile ให้กับทีมของเรา

​	ตลอดเวลาที่ได้ทำงานร่วมกับทีม TW ทำให้เรารู้เลยว่าทำไมเราจึงต้องทำ TDD และเป็นที่มาว่าทำไม Restify ของเรามึงมี folder test แล้ว

​	อีกสิ่งหนึ่งที่ได้แนวคิดจาก TW ก็คงเป็นส่ิงที่เรียกว่า **Infrastructure as Code** ที่เรายังคงทำมันอยู่เรียกได้ว่าตอนนี้ Configuration management ต่างๆของ Infrastructure ของฟังใจทั้งหมดอยู่บน Git ซึ่งมันทำให้ชีวิตเราง่ายมาก

### ทำไมเราต้องทำ Infrastructure as Code

​	สำหรับผมคำตอบน่าจะคล้ายๆทำไมเราใช้ git ใช้ svn คือได้ทำ version ของ source code เผื่อมีอะไรผิดพลาดไป ก็ได้ย้อนกลับไปได้

#### ปัญหาที่ผมเจอบ่อย

​	ขอย้อนกลับไปไกลอีกนิดนึงละกัน อันที่จริงแล้วผมเป็น Android progammer ซึ่งเมื่อก่อนผมเคยเขียน iOS แต่ก่อนหน้านั้นผมเขียน J2EE ต่อกับ Flex (ActionScript 3) เมื่อเราเขียน Mobile แล้วบ่อยครั้งเราก็ต้องเขียน API เอาไว้เล่นเองเพื่อรับส่ง Data ไปมา

​	เวลาทำงานอะไรเองเล่นๆ ผมก็ต้องลง OS จากนั้นลง mysql, java เพื่อจะเอาไว้รัน Grails กับ Jetty แล้วก็ลง Nginx เอาไว้ทำ reverse proxy จาก port 80->8080

​	ด้วยความที่ผมลองเล่นอะไรบ่อย เขียน App ปัญญาอ่อนออกมาเยอะมาก ทำให้เราก็ต้องทำงานเหล่านี้ซ้ำๆเยอะมาก และทุกครั้งผมก็ต้อง Search แล้วทำตาม Tutorial

#### วิธีการแก้ปัญหาของผม

​	ช่วงแรกๆ ทำไมเราต้องคอย Search ทุกครั้งเลยวะ นี่ไง ก็ทำ blog เองซะเลยเวลา search ก็จะได้เจอของตัวเอง เจ๋งปะล่ะ ผ่านมาหลายปีผมก็ทำได้แค่นั้น เชื่อว่าหลายๆคนอาจจะเก่งกว่าผม โดยการอาจจะเขียน bash ไฟล์ไว้ก็เป็นได้

***แน่นอนผมรู้ว่าผมมีปัญหา แต่ผมไม่เคยคิดหาทางแก้ไขมันเลยในตอนนั้น***

### จนมาพบกับ Ansible + Vagrant

​	ตอนแรกรู้สึกแปลกใจมากหลังจากที่ DevOps ของ TW ที่เข้ามาช่วยใน project ได้ลองเขียน script ให้เราดูใน **Iteration 0** ของ project จากนั้นก็ต้องแอบเอา code ของเค้ามาลองเล่นเองในตอนกลางคืน เริ่มต้นจากง่ายๆคือการสร้าง Configuration file ของ Macbook ของเราเอง ว่าถ้ามีเครื่องใหม่มา เราจะต้องลงโปรแกรมอะไรบ้าง เพื่อใช้ในการเขียนโปรแกรม [**workstation**](https://goo.gl/CBVtsP)

```
├── ansible.cfg
├── bootstrap.sh
├── eb
├── group_vars
│   ├── Darwin
│   └── all
├── hosts.ini
├── library
│   └── mac_pkg
├── playbook.yml
├── roles
│   ├── android
│   │   ├── tasks
│   │   └── vars
│   ├── common
│   │   ├── tasks
│   │   └── vars
│   ├── docker
│   │   └── tasks
│   ├── golang
│   │   └── tasks
│   ├── intellij
│   │   └── tasks
│   ├── java
│   │   └── tasks
│   ├── nodejs
│   │   └── tasks
│   ├── redis
│   │   └── tasks
│   └── sublime
│       └── tasks
└── uninstall_homebrew.sh
```

​	ซึ่งมันก็แค่ลง Application ตาม list ที่ผมระบุไว้ เช่น Java, Android Studio, Redis, NodeJS, Sublime, Docker, GO , IntelliJ, Chrome, Ruby, vim, iTerm, zsh, git และอื่นๆอีกมามาย



> รู้สึกว่าตอนนี้เขียนเหมือน Diary มากกว่าจะพูดเรื่อง fungjai infra แล้ว ไว้ต่อตอนหน้าดีกว่าจะได้เล่าว่าทำไมถึงออกแบบ infra แบบที่เป็นอยู่ในปัจุบัน แต่บอกเลยว่ามันกำลังจะเปลี่ยนในไม่ช้านี้
>
> แอบบอก stats นิดหน่อย คนที่กดหน้าแรกจาก fb มา อ่านหรือไม่อ่านไม่รู้ กดมาหน้า นี้แค่ 10% (June 8, 2016) อาจจะเพราะผมทำปุ่มเล็กหรือปล่าวไม่รู้ ไว้ลองเทสใหม่



**[<<  ตอนก่อนหน้า จุดเริ่มต้นของปัญหา](README.md) | [ตอนต่อไป เมื่อ Server ใหม่มาถึง](new-server-comming.md)  >>**

[![Analytics](https://ga-beacon.appspot.com/UA-79032210-1/ep2?pixel)](fungjai-infra-2.md)
